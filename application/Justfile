#!/usr/bin/env just --justfile
import "recipes.justfile"

# Use bash as the shell for evaluating backtick expressions
set shell := ["bash", "-cu"]

# -------------------------------------------------------------------------------------------------
# Runtime variables
# -------------------------------------------------------------------------------------------------
port := "9100"
ui-port := "3000"
webcam-device := "/dev/video0"
host := "0.0.0.0"
enable-coturn := "false"
stun-server := ""
webrtc-ports := "50000-51000"
device := "cpu"  # cpu, cu128, xpu

# Note: Binding port 443 may conflict with other services (e.g., HTTPS) on this host. Replace it with whatever port works/open for you.
coturn-port := "443"

# -------------------------------------------------------------------------------------------------
# Variables used in the Justfile to build in Docker image
# -------------------------------------------------------------------------------------------------
docker-build-context := ""
build-target := "cpu"  # options: cpu, cuda, xpu
component-name := "geti-prompt"
container-registry := 'localhost:5000/open-edge-platform'
version := "latest"
image-name := container-registry / component-name / build-target + ":" + version

source-dataset-dir := "backend/.data/templates/datasets/coffee-berries"
target-dataset-dir := "/geti_prompt/data/templates/datasets/coffee-berries"

# Coturn settings
coturn-image := "quay.io/coturn/coturn"

host-ip := `uv run python -c "import socket; s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM); s.connect(('8.8.8.8',80)); print(s.getsockname()[0]); s.close()"`

docker-build-args := "--build-arg http_proxy --build-arg https_proxy --build-arg no_proxy --build-arg HTTP_PROXY --build-arg HTTPS_PROXY --build-arg NO_PROXY"
docker-run-args := "--env http_proxy --env https_proxy --env no_proxy --env HTTP_PROXY --env HTTPS_PROXY --env NO_PROXY"


# Run both backend and frontend development servers
dev:
    #!/usr/bin/env bash
    set -euo pipefail

    export PUBLIC_API_URL="http://{{ host-ip }}:{{ port }}"

    {{ if enable-coturn == "true" { "just run-coturn" } else { "" } }}

    trap 'kill $(jobs -p) 2>/dev/null || true; {{ if enable-coturn == "true" { "just stop-coturn" } else { "" } }}' EXIT

    (cd backend && just port={{ port }} host={{ host }} device={{ device }} enable-coturn={{ enable-coturn }} stun-server={{ stun-server }} coturn-port={{ coturn-port }} dev) &
    (cd ui && npm install && PORT={{ ui-port }} npm start) &

    wait

# build geti prompt with optional port mapping
build-image: (download-dataset source-dataset-dir)
    @echo "Building docker image for component: {{ component-name }}"
    @docker build \
        {{ docker-build-args }} \
        {{ docker-build-context }} \
        --build-context libs=../library \
        --build-arg SOURCE_DATASET_DIR={{ source-dataset-dir }} \
        --build-arg TARGET_DATASET_DIR={{ target-dataset-dir }} \
        --build-arg DEVICE={{ device }} \
        --tag "{{ image-name }}" \
        --file docker/Dockerfile . \
        --target {{ build-target }}

# To persist the database, add this to `docker run` args:
# `--volume "{{ component-name }}-data":/geti_prompt/data \`
# To persist logs, add this to `docker run` args:
# `--volume "{{ component-name }}-logs":/geti_prompt/logs \`
# Add either line, or both.
# launch geti prompt with optional webcam, volume and port mapping
run-image: build-image
    #!/usr/bin/env bash
    set -euo pipefail

    extra_render_args=()
    if [[ "{{ device }}" == "xpu" ]]; then
      RENDER_GID=$(uv run python -c "import grp; print((grp.getgrnam('render').gr_gid) if any(g.gr_name == 'render' for g in grp.getgrall()) else '')")
      RENDER_NODE=$(uv run python -c "from pathlib import Path; print(render_nodes[0]) if (render_nodes := sorted(Path('/dev/dri').glob('renderD*'))) else ''")
      if [[ -n "$RENDER_NODE" ]]; then
        extra_render_args+=(--device "$RENDER_NODE")
      fi
      if [[ -n "$RENDER_GID" ]]; then
        extra_render_args+=(--group-add "$RENDER_GID")
      fi
    fi

    echo "Running docker image for component: {{ component-name }} with build-target: {{ build-target }}"
    echo "Proxy args: {{ docker-run-args }}"
    docker run --rm \
        {{ docker-run-args }} \
        --sysctl net.ipv4.ip_local_port_range="{{ replace(webrtc-ports, '-', ' ') }}" \
        --publish {{ webrtc-ports }}:{{ webrtc-ports }}/udp \
        --publish {{ port }}:{{ port }} \
        --env PORT={{ port }} \
        --env HOST={{ host }} \
        {{ if enable-coturn == "true" { "--env COTURN_HOST='" + host-ip + "' --env COTURN_PORT='" + coturn-port + "'" } else { "" } }} \
        {{ if stun-server != "" { "--env STUN_SERVER='" + stun-server + "'" } else { "" } }} \
        --env WEBRTC_ADVERTISE_IP='{{ host-ip }}' \
        {{ if path_exists(webcam-device) == "true" { " --device " + webcam-device + ":" + webcam-device } else { "" } }} \
        "${extra_render_args[@]}" \
        --name "{{ component-name }}-{{ version }}" \
        "{{ image-name }}"

# run coturn server
run-coturn:
    @echo "Running coturn server on port {{ coturn-port }} with external IP {{ host-ip }}..."
    @docker run --rm --detach \
        --network=host \
        --name coturn-server \
        {{ coturn-image }} \
        -n \
        --listening-port={{ coturn-port }} \
        --external-ip={{ host-ip }} \
        --user=user:password \
        --realm=my-realm \
        --no-udp \
        --log-file=stdout \
        --verbose

# stop coturn server
stop-coturn:
    @echo "Stopping coturn server..."
    @docker stop coturn-server || true

# show size of the built docker image
show-size:
    # https://github.com/casey/just?tab=readme-ov-file#escaping-
    @docker image inspect "{{ image-name }}" --format='{{{{.Size}}' | numfmt --to=iec

# test geti prompt docker image using bash script
test-image:
    #!/usr/bin/env bash
    echo "Testing docker image for component: {{ component-name }} with build-target: {{ build-target }}"

    # Start the container in detached mode
    CONTAINER_ID=$(docker run -d \
        {{ docker-run-args }} \
        --publish {{ port }}:{{ port }} \
        --env PORT={{ port }} \
        --env HOST={{ host }} \
        "{{ image-name }}")
    echo "Started container: $CONTAINER_ID"

    # Function to cleanup container on exit
    cleanup() {
        echo "Cleaning up container: $CONTAINER_ID"
        docker stop $CONTAINER_ID || true
    }
    trap cleanup EXIT

    TEST_URL="http://{{ component-name }}.localhost:{{ port }}"
    # Wait for container to be ready (max 60 seconds)
    echo "Waiting for container to be ready..."
    for i in {1..12}; do
      if no_proxy=localhost curl -sf $TEST_URL/health > /dev/null 2>&1; then
          echo "✅ Health check passed!"
          break
      fi
      if [ $i -eq 12 ]; then
          echo "❌ Health check failed after 60 seconds"
          docker logs $CONTAINER_ID
          exit 1
      fi
      echo "Attempt $i/12 - waiting 5 seconds..."
      sleep 5
    done

    EXPECTED_TITLE="Geti Prompt"
    echo "Checking HTML title..."

    HTML_CONTENT=$(no_proxy=localhost curl -sf $TEST_URL)
    if echo "$HTML_CONTENT" | grep -q "<title>.*$EXPECTED_TITLE.*</title>"; then
      echo "✅ HTML title check passed - found: $EXPECTED_TITLE"
    else
      echo "❌ HTML title check failed - expected title '$EXPECTED_TITLE' not found"
      echo "Actual HTML content:"
      echo "$HTML_CONTENT"
      exit 1
    fi

    echo "All checks passed successfully!"
