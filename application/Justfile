#!/usr/bin/env just --justfile

# -------------------------------------------------------------------------------------------------
# Runtime variables
# -------------------------------------------------------------------------------------------------

container-port := "9100"
host-port := container-port
webcam-device := "/dev/video0"
docker-volume := ""
host := "0.0.0.0"

# -------------------------------------------------------------------------------------------------
# Common variables used in the Justfile
# -------------------------------------------------------------------------------------------------

ai-device := "cpu"  # options: cpu, gpu, xpu
component-name := "geti-prompt"
images-registry := 'localhost:5000/open-edge-platform'
version := `cat $(git rev-parse --show-toplevel 2>/dev/null)/VERSION`
docker-image := images-registry / component-name / ai-device + ":" + version

# -------------------------------------------------------------------------------------------------
# Variables used in the Justfile to build in Docker image for Geti Prompt
# -------------------------------------------------------------------------------------------------

docker-build-context := ""
asset-prefix := "/html"
static-files-dir := "/geti_prompt/html"
db-data-dir := "/geti_prompt/data"
coffee-berries-dataset := "https://storage.geti.intel.com/geti-prompt/Frames.zip"

# Dataset paths
application-dir := justfile_directory()
source-dataset-dir := ".data/templates/datasets/coffee-berries"
target-dataset-dir := "/geti_prompt/data/templates/datasets/coffee-berries"

# -------------------------------------------------------------------------------------------------
# Proxy settings
# -------------------------------------------------------------------------------------------------

http-proxy-build-arg := if env("http_proxy", "") != "" { " --build-arg http_proxy=" + env("http_proxy") } else { "" }
https-proxy-build-arg := if env("https_proxy", "") != "" { " --build-arg https_proxy=" + env("https_proxy") } else { "" }
no-proxy-build-arg := if env("no_proxy", "") != "" { " --build-arg no_proxy=" + env("no_proxy") } else { "" }
HTTP-PROXY-build-arg := if env("HTTP_PROXY", "") != "" { " --build-arg HTTP_PROXY=" + env("HTTP_PROXY") } else { "" }
HTTPS-PROXY-build-arg := if env("HTTPS_PROXY", "") != "" { " --build-arg HTTPS_PROXY=" + env("HTTPS_PROXY") } else { "" }
NO-PROXY-build-arg := if env("NO_PROXY", "") != "" { " --build-arg NO_PROXY=" + env("NO_PROXY") } else { "" }
docker-extra-args := http-proxy-build-arg + https-proxy-build-arg + no-proxy-build-arg + HTTP-PROXY-build-arg + HTTPS-PROXY-build-arg + NO-PROXY-build-arg

# -------------------------------------------------------------------------------------------------
# Justfile recipes
# -------------------------------------------------------------------------------------------------

check-proxy:
    #!/usr/bin/env bash
    if [ -z ${https_proxy+x} ]; then
      echo "Error: https_proxy is unset";
    else
      echo "https_proxy is set to '$https_proxy'";
    fi

download-dataset: check-proxy
    #!/usr/bin/env bash
    DATASET_DIR="{{ application-dir }}/{{ source-dataset-dir }}"
    if [ -d "$DATASET_DIR" ] && [ "$(ls -A $DATASET_DIR)" ]; then
        echo "Dataset directory $DATASET_DIR already exists and is not empty. Skipping download."
        exit 0
    fi
    mkdir -p $DATASET_DIR
    echo "Downloading default dataset from {{ coffee-berries-dataset }}"
    if ! wget -q --show-progress {{ coffee-berries-dataset }}; then
        echo "Error: Failed to download dataset from {{ coffee-berries-dataset }}"
        exit 0  # proceed without dataset
    fi
    echo "Unpacking default dataset to $DATASET_DIR"
    unzip -j -q -o Frames.zip -d $DATASET_DIR
    echo "Removing downloaded dataset archive Frames.zip"
    rm Frames*.zip

# build geti prompt with optional port mapping
build-image: download-dataset
    @echo "Building docker image for component: {{ component-name }}"
    @docker build \
        {{ docker-extra-args }} \
        {{ docker-build-context }} \
        --build-context libs=../library \
        --build-arg PUBLIC_API_URL=http://localhost:{{ container-port }} \
        --build-arg STATIC_FILES_DIR={{ static-files-dir }} \
        --build-arg DB_DATA_DIR={{ db-data-dir }} \
        --build-arg ASSET_PREFIX={{ asset-prefix }} \
        --build-arg SOURCE_DATASET_DIR={{ source-dataset-dir }} \
        --build-arg TARGET_DATASET_DIR={{ target-dataset-dir }} \
        --tag "{{ docker-image }}" \
        --file docker/Dockerfile . \
        --target {{ ai-device }}

# launch geti prompt with optional webcam, volume and port mapping
run-image: build-image
    @echo "Running docker image for component: {{ component-name }} with ai-device: {{ ai-device }}"
    @docker run --rm \
        --publish {{ host-port }}:{{ container-port }} \
        --env PORT={{ container-port }} \
        --env HOST={{ host }} \
        {{ if docker-volume != "" { " --volume " + docker-volume + ":" + db-data-dir } else { "" } }} \
        {{ if path_exists(webcam-device) == "true" { " --device " + webcam-device + ":" + webcam-device } else { "" } }} \
        --name "{{ component-name }}-{{ version }}" \
        "{{ docker-image }}"

# show size of the built docker image
show-size:
    # https://github.com/casey/just?tab=readme-ov-file#escaping-
    @docker image inspect "{{ docker-image }}" --format='{{{{.Size}}' | numfmt --to=iec

# test geti prompt docker image using bash script
test-image:
    #!/usr/bin/env bash
    echo "Testing docker image for component: {{ component-name }} with ai-device: {{ ai-device }}"

    # Start the container in detached mode
    CONTAINER_ID=$(docker run -d --rm \
        --publish {{ host-port }}:{{ container-port }} \
        --env PORT={{ container-port }} \
        --env HOST={{ host }} \
        "{{ docker-image }}")
    echo "Started container: $CONTAINER_ID"

    # Function to cleanup container on exit
    cleanup() {
        echo "Cleaning up container: $CONTAINER_ID"
        docker stop $CONTAINER_ID || true
    }
    trap cleanup EXIT

    TEST_URL="http://{{ component-name }}.localhost:{{ host-port }}"
    # Wait for container to be ready (max 60 seconds)
    echo "Waiting for container to be ready..."
    for i in {1..12}; do
      if no_proxy=localhost curl -sf $TEST_URL/health > /dev/null 2>&1; then
          echo "✅ Health check passed!"
          break
      fi
      if [ $i -eq 12 ]; then
          echo "❌ Health check failed after 60 seconds"
          docker logs $CONTAINER_ID
          exit 1
      fi
      echo "Attempt $i/12 - waiting 5 seconds..."
      sleep 5
    done

    EXPECTED_TITLE="Geti Prompt"
    echo "Checking HTML title..."

    HTML_CONTENT=$(no_proxy=localhost curl -sf $TEST_URL)
    if echo "$HTML_CONTENT" | grep -q "<title>.*$EXPECTED_TITLE.*</title>"; then
      echo "✅ HTML title check passed - found: $EXPECTED_TITLE"
    else
      echo "❌ HTML title check failed - expected title '$EXPECTED_TITLE' not found"
      echo "Actual HTML content:"
      echo "$HTML_CONTENT"
      exit 1
    fi

    echo "All checks passed successfully!"
