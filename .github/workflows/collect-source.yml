name: Collect source for GPL/MPL licensed code (combined)

on:
  workflow_dispatch:

permissions: {} # No permissions by default on workflow level

jobs:
  collect-packages-names:
    name: Generate SBOM with Syft
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      matrix:
        ai-device: [cpu, cuda, xpu]
    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          ref: ${{ github.sha }}
          persist-credentials: false

      - name: Install dependencies
        uses: ./.github/actions/install-dependencies
        with:
          cleanup-runner: "true"

      - name: Build docker image
        working-directory: application
        id: image-name
        env:
          DEVICE: ${{ matrix.ai-device }}
        run: |
          just build-target="${DEVICE}" docker-build-context="--no-cache" build-image
          IMAGE_NAME=$(just --evaluate build-target="${DEVICE}" image-name)
          echo "image=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "Image: ${IMAGE_NAME}"

      - name: Cleanup docker cache
        run: docker builder prune -f

      - name: Scan ${{ matrix.ai-device }}
        shell: bash
        env:
          TARGET: ${{ steps.image-name.outputs.image }}
          DEVICE: ${{ matrix.ai-device }}
        run: |
          # install Syft
          curl -sSfL https://get.anchore.io/syft | sudo sh -s -- -b /usr/local/bin
          NAME=$(echo "$TARGET" | cut -d'/' -f 4 | cut -d':' -f 1)
          echo "name=$NAME" >> $GITHUB_ENV

          syft "$TARGET" -o json |
          jq -r '[
            .artifacts[] |
            select(.type == "deb" and ((.licenses // [])[]?.value | test("GPL|AGPL|LGPL|EPL|MPL"; "i"))) |
            .name
          ] | unique[]' > pkg_list_$DEVICE.txt

      - name: Upload packages list
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: pkg_list_${{ matrix.ai-device }}
          path: pkg_list_*
          retention-days: 5

  get-unique-names:
    runs-on: ubuntu-latest
    needs:
      - collect-packages-names
    outputs:
      unique_package_names_oneline: ${{ steps.transform-list.outputs.unique_package_names_oneline }}
    steps:
      # Create directory first
      - name: Create results directory
        run: mkdir -p all-pkg_list

      # Download all reports
      - name: Download all reports
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          pattern: "pkg_list_*"
          merge-multiple: true
          path: all-pkg_list

      - name: Get unique names
        id: transform-list
        shell: bash
        run: |
          cat all-pkg_list/* | sort -u > merged_unique.txt
          cat merged_unique.txt
          awk 'ORS=","{print}' merged_unique.txt | sed 's/,$//' > unique_package_names_oneline.txt
          echo "unique_package_names_oneline=$(cat unique_package_names_oneline.txt)" >> $GITHUB_OUTPUT

  collect-source-code:
    runs-on: ubuntu-latest
    needs: get-unique-names
    container:
      image: debian:bookworm-slim@sha256:98f4b71de414932439ac6ac690d7060df1f27161073c5036a7553723881bffbe
    steps:
      - name: Add apt sources for deb-src
        shell: bash
        run: |
          sed -Ei "s/^Types: deb$/Types: deb deb-src/" /etc/apt/sources.list.d/debian.sources
          apt-get update

      - name: Find GPL/MPL licensed packages
        shell: bash
        env:
          PACKAGES: ${{ needs.get-unique-names.outputs.unique_package_names_oneline }}
        run: |
          OUTPUT_DIR="output"
          ARCHIVE_NAME="source_code.tar.gz"
          mkdir -p "$OUTPUT_DIR"
          cd "$OUTPUT_DIR"
          # Split comma-separated list into an array
          IFS=',' read -r -a PACKAGES_ARR <<< "$PACKAGES"
          # Collect missing packages
          # Install GNU Parallel for faster downloads
          apt-get update && apt-get install -y parallel

          # Download sources for GPL/MPL packages in parallel with error handling
          if [ ${#PACKAGES_ARR[@]} -gt 0 ]; then
            export OUTPUT_DIR
            printf "%s\n" "${PACKAGES_ARR[@]}" | parallel --jobs 4 '
              echo "Downloading source for {}"
              if ! apt-get source -q --download-only "{}"; then
                echo "Warning: Source not available for {}" >&2
              fi
            '
          fi
          cd ..
          tar -czf "$ARCHIVE_NAME" -C "$OUTPUT_DIR" .

      - name: Upload source code archive
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: source-code-archive
          path: source_code.tar.gz
          retention-days: 3
